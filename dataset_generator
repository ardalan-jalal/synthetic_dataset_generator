from PIL import Image, ImageDraw, ImageFont
import os
import random
import glob
import re

# Directory to save synthetic images
OUTPUT_DIR = "dataset"
FONT_DIR = "fonts"
TEXT_DIR = "input/raw_text"
os.makedirs(OUTPUT_DIR, exist_ok=True)

# Number of images to generate
NUM_IMAGES = 100  # Set this to control how many images you want to generate

# Maximum characters per line Lines longer than this will be split
MAX_LINE_LENGTH = 80  

# Split long lines into manageable chunks for better training
def split_long_lines(text, max_length=150):
    """Split text into chunks at sentence boundaries for realistic line lengths"""
    if len(text) <= max_length:
        return [text]

    # Split on common sentence boundaries (period, comma, semicolon, etc.)
    # Kurdish/Arabic punctuation: ، (comma), ؛ (semicolon), . ! ?
    sentences = re.split(r"([.!?،؛])\s+", text)

    chunks = []
    current_chunk = ""

    for i, part in enumerate(sentences):
        # Check if it's a punctuation mark
        if part in ".!?،؛":
            current_chunk += part
        else:
            # If adding this would exceed max length, save current chunk
            if current_chunk and len(current_chunk) + len(part) > max_length:
                chunks.append(current_chunk.strip())
                current_chunk = part
            else:
                current_chunk += part

    # Add the last chunk
    if current_chunk and current_chunk.strip():
        chunks.append(current_chunk.strip())

    # If splitting didn't help, force split at max_length
    if not chunks:
        chunks = [text[i : i + max_length] for i in range(0, len(text), max_length)]

    return chunks


# Read text from input file
text_file_path = os.path.join(TEXT_DIR, "text.txt")
with open(text_file_path, "r", encoding="utf-8") as f:
    lines = f.readlines()

# Filter out empty lines and strip whitespace
raw_texts = [line.strip() for line in lines if line.strip()]

# Split long lines into manageable chunks for better training
texts = []
for text in raw_texts:
    texts.extend(split_long_lines(text, MAX_LINE_LENGTH))

print(f"Original lines: {len(raw_texts)}, After splitting long lines: {len(texts)}")

# Get all font files from fonts directory
font_files = glob.glob(os.path.join(FONT_DIR, "*.ttf"))
if not font_files:
    raise ValueError(f"No .ttf font files found in {FONT_DIR} directory")

# Tesseract LSTM best practices
TARGET_TEXT_HEIGHT = 32  # Optimal text height for Tesseract (30-33px recommended)
PADDING = 10  # Padding around text (minimum 5-10px recommended)


# Find optimal font size to achieve target text height
def get_optimal_font_size(font_path, sample_text, target_height):
    """Calculate font size that produces text close to target height"""
    font_size = 32
    for size in range(20, 100):
        test_font = ImageFont.truetype(font_path, size)
        bbox = test_font.getbbox(sample_text)
        text_height = bbox[3] - bbox[1]
        if text_height >= target_height:
            return size
    return font_size


for i in range(NUM_IMAGES):
    # Randomly select a line of text
    text = random.choice(texts)

    # Randomly select a font for this image
    selected_font_path = random.choice(font_files)
    font_name = os.path.basename(selected_font_path)

    # Calculate optimal font size for the selected font
    optimal_font_size = get_optimal_font_size(
        selected_font_path, text, TARGET_TEXT_HEIGHT
    )
    font = ImageFont.truetype(selected_font_path, optimal_font_size)

    # Calculate image size based on text length
    bbox = font.getbbox(text)
    text_width = bbox[2] - bbox[0]
    text_height = bbox[3] - bbox[1]

    # Add padding (2x on each side for safety)
    img_width = text_width + (PADDING * 2)
    img_height = text_height + (PADDING * 2)

    # Ensure minimum height for consistency
    if img_height < TARGET_TEXT_HEIGHT + (PADDING * 2):
        img_height = TARGET_TEXT_HEIGHT + (PADDING * 2)

    # Create a white background image
    img = Image.new("RGB", (img_width, img_height), color=(255, 255, 255))

    # Draw text on image (center vertically accounting for font bbox offset)
    draw = ImageDraw.Draw(img)
    # Account for the bounding box top offset for proper centering
    y_offset = (img_height - text_height) // 2 - bbox[1]
    draw.text((PADDING, y_offset), text, fill=(0, 0, 0), font=font)

    # Save the image
    img_path = os.path.join(OUTPUT_DIR, f"img_{i}.tif")
    img.save(img_path, dpi=(300, 300))

    # Save ground truth text file
    gt_path = os.path.join(OUTPUT_DIR, f"img_{i}.gt.txt")
    with open(gt_path, "w", encoding="utf-8") as gt_file:
        gt_file.write(text)