from PIL import Image, ImageDraw, ImageFont
import os
import random
import glob
import re
import json

# Directory to save synthetic images
OUTPUT_DIR = "dataset"
FONT_DIR = "fonts"
TEXT_DIR = "input/raw_text"

# Number of images to generate
NUM_IMAGES = 10  # Set this to control how many images you want to generate

# Maximum characters per line Lines longer than this will be split
MAX_LINE_LENGTH = 100


# Split long lines into manageable chunks for better training
def split_long_lines(text, max_length=150):
    """Split text into chunks at sentence boundaries for realistic line lengths"""
    if len(text) <= max_length:
        return [text]

    # Step 1: Try splitting on punctuation boundaries
    # Kurdish/Arabic punctuation: ، (comma), ؛ (semicolon), . ! ?
    sentences = re.split(r"([.!?،؛])\s+", text)

    chunks = []
    current_chunk = ""

    for part in sentences:
        # Check if it's a punctuation mark
        if part in ".!?،؛":
            current_chunk += part
        else:
            # If adding this would exceed max length, save current chunk
            if current_chunk and len(current_chunk) + len(part) + 1 > max_length:
                chunks.append(current_chunk.strip())
                current_chunk = part
            else:
                current_chunk += (
                    (" " + part)
                    if current_chunk
                    and not current_chunk.endswith((".", "!", "?", "،", "؛"))
                    else part
                )

    # Add the last chunk
    if current_chunk and current_chunk.strip():
        chunks.append(current_chunk.strip())

    # Step 2: CRITICAL - Validate and force-split any chunk still exceeding max_length
    final_chunks = []
    for chunk in chunks:
        if len(chunk) <= max_length:
            final_chunks.append(chunk)
        else:
            # Split on word boundaries
            words = chunk.split()
            temp_line = ""

            for word in words:
                # Check if adding this word would exceed limit
                test_line = (temp_line + " " + word) if temp_line else word

                if len(test_line) <= max_length:
                    temp_line = test_line
                else:
                    # Save current line if it exists
                    if temp_line:
                        final_chunks.append(temp_line)
                        temp_line = word
                    else:
                        # Single word exceeds max_length - hard split it
                        final_chunks.append(word[:max_length])
                        temp_line = word[max_length:]

            # Don't forget the last line
            if temp_line:
                final_chunks.append(temp_line)

    # Fallback: if somehow still empty, hard split original text
    return (
        final_chunks
        if final_chunks
        else [text[i : i + max_length] for i in range(0, len(text), max_length)]
    )


# Read text from input file
text_file_path = os.path.join(TEXT_DIR, "text.txt")
with open(text_file_path, "r", encoding="utf-8") as f:
    lines = f.readlines()

# Filter out empty lines and strip whitespace
raw_texts = [line.strip() for line in lines if line.strip()]

# Split long lines into manageable chunks for better training
texts = []
for text in raw_texts:
    texts.extend(split_long_lines(text, MAX_LINE_LENGTH))

# Get all font files from fonts directory
font_files = (
    glob.glob(os.path.join(FONT_DIR, "*.ttf"))
    + glob.glob(os.path.join(FONT_DIR, "*.TTF"))
    + glob.glob(os.path.join(FONT_DIR, "*.otf"))
)
# Sort fonts alphabetically for consistent indexing
font_files = sorted(font_files)

# Create font-to-index mapping (1-based)
font_to_index = {font_path: idx + 1 for idx, font_path in enumerate(font_files)}

# Prepare font mapping for JSON
font_mapping = {
    f"f{idx:02d}": {
        "font_file": os.path.basename(font_path),
        "index": idx,
    }
    for font_path, idx in font_to_index.items()
}

# Save font index to JSON file
font_index_file = os.path.join("font_index.json")
with open(font_index_file, "w", encoding="utf-8") as f:
    json.dump(font_mapping, f, indent=2, ensure_ascii=False)


if not font_files:
    raise ValueError(f"No .ttf or .otf font files found in {FONT_DIR} directory")
print(f"Found {len(font_files)} fonts: {[os.path.basename(f) for f in font_files]}")

# Tesseract LSTM best practices
TARGET_TEXT_HEIGHT = 32  # Optimal text height for Tesseract (30-33px recommended)
PADDING = 10  # Padding around text (minimum 5-10px recommended)


# Find optimal font size to achieve target text height
def get_optimal_font_size(font_path, sample_text, target_height):
    """Calculate font size that produces text close to target height"""
    font_size = 32
    for size in range(20, 100):
        test_font = ImageFont.truetype(font_path, size)
        bbox = test_font.getbbox(sample_text)
        text_height = bbox[3] - bbox[1]
        if text_height >= target_height:
            return size
    return font_size


# Generate images
for i in range(NUM_IMAGES):
    # Randomly select a line of text
    text = random.choice(texts)

    # Randomly select a font for this image
    selected_font_path = random.choice(font_files)
    font_name = os.path.basename(selected_font_path)

    # Calculate optimal font size for the selected font
    optimal_font_size = get_optimal_font_size(
        selected_font_path, text, TARGET_TEXT_HEIGHT
    )
    font = ImageFont.truetype(selected_font_path, optimal_font_size)

    # Calculate image size based on text length
    bbox = font.getbbox(text)
    text_width = bbox[2] - bbox[0]
    text_height = bbox[3] - bbox[1]

    # Add padding (2x on each side for safety)
    img_width = text_width + (PADDING * 2)
    img_height = text_height + (PADDING * 2)

    # Ensure minimum height for consistency
    if img_height < TARGET_TEXT_HEIGHT + (PADDING * 2):
        img_height = TARGET_TEXT_HEIGHT + (PADDING * 2)

    # Create a white background image
    img = Image.new("RGB", (img_width, img_height), color=(255, 255, 255))

    # Draw text on image (center vertically accounting for font bbox offset)
    draw = ImageDraw.Draw(img)
    # Account for the bounding box top offset for proper centering
    y_offset = (img_height - text_height) // 2 - bbox[1]
    draw.text((PADDING, y_offset), text, fill=(0, 0, 0), font=font)

    # Save the image
    img_path = os.path.join(OUTPUT_DIR, f"img_{i}.tif")
    img.save(img_path, dpi=(300, 300))

    # Save ground truth text file
    gt_path = os.path.join(OUTPUT_DIR, f"img_{i}.gt.txt")
    with open(gt_path, "w", encoding="utf-8") as gt_file:
        gt_file.write(text)
